// api/generate-prediction.js - –°–µ—Ä–≤–µ—Ä–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ò–ò-–ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π —á–µ—Ä–µ–∑ n8n
const crypto = require('crypto');

export default async function handler(req, res) {
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º CORS –∑–∞–≥–æ–ª–æ–≤–∫–∏
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º preflight –∑–∞–ø—Ä–æ—Å—ã
    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { user_id, question, cards, type, userName } = req.body;

        if (!cards || (!Array.isArray(cards) && !cards.name)) {
            return res.status(400).json({ error: 'Missing required fields: cards' });
        }

        // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∫–∞–∫ –º–∞—Å—Å–∏–≤ –∫–∞—Ä—Ç, —Ç–∞–∫ –∏ –æ–¥–Ω—É –∫–∞—Ä—Ç—É
        const card = Array.isArray(cards) ? cards[0] : cards;

        console.log('üîÆ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–ª—è –∫–∞—Ä—Ç—ã:', card.name);

        // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —á–µ—Ä–µ–∑ n8n
        try {
            const prediction = await generateN8nPrediction({
                user_id: user_id || 'webapp_user',
                userName: userName || '–ì–æ—Å—Ç—å', 
                question: question || '',
                card: card,
                type: type || 'single_card'
            });

            return res.status(200).json({
                success: true,
                prediction: prediction.prediction,
                source: 'n8n',
                user: prediction.user || null,
                timestamp: prediction.timestamp
            });

        } catch (n8nError) {
            console.error('‚ùå n8n Error:', n8nError.message);
            console.log('üîÑ Fallback –∫ –ª–æ–∫–∞–ª—å–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...');
            
            // Fallback –∫ –ª–æ–∫–∞–ª—å–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            const localPrediction = generateLocalPrediction(card, question);
            
            return res.status(200).json({
                success: true,
                prediction: localPrediction,
                source: 'local',
                user: null,
                timestamp: new Date().toISOString()
            });
        }

    } catch (error) {
        console.error('‚ùå Error generating prediction:', error);
        return res.status(500).json({ 
            error: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.' 
        });
    }
}

async function generateN8nPrediction(data) {
    const n8nConfig = {
        webhookUrl: process.env.N8N_WEBHOOK_URL,
        secret: process.env.N8N_SECRET
    };

    if (!n8nConfig.webhookUrl) {
        throw new Error('N8N_WEBHOOK_URL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω');
    }

    const requestPayload = {
        action: 'generate_prediction',
        telegram_id: data.user_id,
        userName: data.userName,
        card: {
            name: data.card.name,
            symbol: data.card.symbol || 'üîÆ',
            meaning: data.card.meaning
        },
        question: data.question,
        type: data.type
    };

    const payload = JSON.stringify(requestPayload);
    const signature = createHmacSignature(payload, n8nConfig.secret);

    const response = await fetch(n8nConfig.webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-N8N-Sign': signature,
            'User-Agent': 'TarotWebApp/1.0'
        },
        body: payload
    });

    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const result = await response.json();
    
    if (!result.success || !result.prediction) {
        throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç n8n API');
    }

    return result;
}

function createHmacSignature(payload, secret) {
    if (!secret) {
        console.warn('‚ö†Ô∏è N8N_SECRET –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑ –ø–æ–¥–ø–∏—Å–∏');
        return '';
    }
    
    return crypto
        .createHmac('sha256', secret)
        .update(payload)
        .digest('hex');
}

function generateLocalPrediction(card, question) {
    const templates = [
        `–ö–∞—Ä—Ç—ã —É–∫–∞–∑—ã–≤–∞—é—Ç: "${card.name}" —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç ${card.meaning.toLowerCase()}. –í –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –≤–∞—à–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ —ç—Ç–æ –º–æ–∂–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å –ø–µ—Ä–∏–æ–¥ –≤–∞–∂–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω –∏ –Ω–æ–≤—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π.`,
        `–≠–Ω–µ—Ä–≥–∏–∏ "${card.name}" –≥–æ–≤–æ—Ä—è—Ç –æ ${card.meaning.toLowerCase()}. –í—Å–µ–ª–µ–Ω–Ω–∞—è –Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –≤–∞—à–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é –º—É–¥—Ä–æ—Å—Ç—å –∏ –∏–Ω—Ç—É–∏—Ü–∏—é.`,
        `–ú–∏—Å—Ç–∏—á–µ—Å–∫–∞—è —Å–∏–ª–∞ "${card.name}" —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ ${card.meaning.toLowerCase()}. –ü—Ä–∏—Å–ª—É—à–∞–π—Ç–µ—Å—å –∫ –∑–Ω–∞–∫–∞–º, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–∞–µ—Ç –≤–∞–º —Å—É–¥—å–±–∞.`
    ];
    
    return templates[Math.floor(Math.random() * templates.length)];
}
